




//---------------------------------函数说明--------------------------------------------//
//函数功能：	发送一个应答信号(校验成功后才发送应答信号)
//入口参数：	*USARTx:用哪一个串口发送
//				AckSource：指示应答码的发送方，即由谁发送应答码
//				*DATaFrame:收到的的数据帧地址（应答信号需要提取收到的数据帧里面的内容）
//返回值：	无
//---------------------------------函数测试---------------------------------------------//
//text1:生产商服务器收到数据发送应答
//		收到数据：AA 55 07 20 00 01 58 FF FF FF 81 55 AA			生产商收到设备发来的数据
//		发送应答：AA 55 06 00 20 00 03 07 81 A3 55 AA 				生产商发送应答给设备，应答功能码为0x03
//text2：用户服务器收到数据发送应答
//		收到数据：AA 55 07 20 01 01 58 FF FF FF 80 55 AA			用户收到设备发来的数据
//		发送应答：AA 55 06 01 20 00 A7 07 80 07 55 AA 				用户发送应答给设备，应答功能码为0xA7
//text3：设备收到数据发送应答
//		收到数据1：AA 55 07 00 20 01 58 FF FF FF 81 55 AA		设备收到生产商发来的数据
//		发送应答1：AA 55 06 20 00 00 72 07 81 D2 55 AA 			设备发送应答给生产商，应答功能码为0x72
//		收到数据2：AA 55 07 01 20 01 58 FF FF FF 80 55 AA		设备收到用户发来的数据
//		发送应答2：AA 55 06 20 01 00 72 07 80 D2 55 AA 			设备发送应答给用户，应答功能码为0x72
//-------------------------------------------------------------------------------------//
//作者：Liao_tingchun		
//修改日期：2020/05/16
//修改内容：初次完成基本功能
//----------------------------
void SendACK(USART_TypeDef *USARTx,u8 AckSource,u8 *DataFrame)
{
	u8 datalen = 0x06;//该条指令的数据区长度
	u8 AckType;
	u8 *point= DataFrame;
	u8 i=0;	//数据串下标
	if(AckSource == 0x00)		AckType = 0x03;
	else if(AckSource == 0x01)		AckType = 0xA7;
	else if(AckSource == 0x20)		AckType = 0x72;
	u8 SendStr[14] =		//下面只缓存到校验位之前
										{0xAA,0x55,//数据包头
										datalen,//数据段长度
										AckSource,*(point+3),//发送和接收方识别码，
										0x00,//是否需要应答【固定不需要应答】
										AckType,//应答功能码，由总协议文档规定
										*(point+2),*(point+(*(point+2))+3)
										};
	u8 Parity = datalen;
	for(i=3;i<datalen+3;i++)//计算校验数据
		Parity   =Parity^SendStr[i];//按位异或运算
	SendStr[i]=Parity;i++;//添加校验数据
	SendStr[i]=0x55;i++;
	SendStr[i]=0xAA;i++;//添加数据包尾部
//数据帧打包完毕
	USART_SendLenData(USARTx,SendStr,datalen+6);//发送数据包
}
