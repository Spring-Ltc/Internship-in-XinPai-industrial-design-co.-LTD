C51 COMPILER V9.60.0.0   TIMER                                                             05/19/2020 12:05:04 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE TIMER
OBJECT MODULE PLACED IN timer.obj
COMPILER INVOKED BY: F:\keil c51\C51\BIN\C51.EXE procedure\timer.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRI
                    -NT(.\Listings\timer.lst) TABS(2) OBJECT(timer.obj)

line level    source

   1          
   2          /*************  ¹¦ÄÜËµÃ÷  **************
   3          
   4          ±¾³ÌÐòÑÝÊ¾3¸ö¶¨Ê±Æ÷µÄÊ¹ÓÃ¡£
   5          
   6          ¶¨Ê±Æ÷0×ö16Î»×Ô¶¯ÖØ×°10us¶¨Ê±£¬²»ÖÐ¶Ï£¬
   7              ÓÃ»§¿ÉÒÔÐÞ¸ÄÊ±¼ä´Ó¶øÐÞ¸ÄÆµÂÊ£¬Ò²¿ÉÒÔÔÊÐíÖÐ¶Ï£¬µ«×¢ÒâÊ±¼ä²»ÒªÌ«¶Ì£¨Ò»°ã10usÒÔÉÏ£©¡£
   8          
   9          ¶¨Ê±Æ÷1×ö16Î»×Ô¶¯ÖØ×°1ms¶¨Ê±£¬ ÖÐ¶Ï£¬
  10          
  11          ¶¨Ê±Æ÷2×ö16Î»×Ô¶¯ÖØ×°20ms¶¨Ê±£¬ÖÐ¶Ï£¬¡£
  12          
  13          ******************************************/
  14          
  15          #include  "timer.h"
  16          u16 T1_1MS1=0,T0_500MS2=0 ;
  17          u16 T0_100MS1=0;
  18          extern u8 TaskStateScanFlag,TaskUartFlag;
  19          //extern u8 TimeOutSet1;
  20          
  21          void  Timer_config(void)//³õÊ¼»¯ ¶¨Ê±Æ÷`
  22          {
  23   1        TIM_InitTypeDef   TIM_InitStructure;          // 
  24   1        TIM_InitStructure.TIM_ClkSource = TIM_CLOCK_1T; // 16Î»×Ô¶¯ÖØ×°  TIM_16BitAutoReload,TIM_16Bit,TIM_8BitAu
             -toReload,TIM_16BitAutoReloadNoMask
  25   1        TIM_InitStructure.TIM_Polity    = PolityLow;      // ÓÅÏÈ¼¶µÍ PolityHigh,PolityLow
  26   1        TIM_InitStructure.TIM_Interrupt = ENABLE;       // Ê¹ÄÜ  ENABLE?¨°DISABLE
  27   1        TIM_InitStructure.TIM_ClkSource = TIM_CLOCK_1T;     //Ê¹ÓÃÊ±ÖÓ1  TIM_CLOCK_1T,TIM_CLOCK_12T,TIM_CLOCK_Ext
  28   1        TIM_InitStructure.TIM_ClkOut    = DISABLE;        //  ¿É±à³ÌÊ±ÖÓÊä³öÊ¹ÄÜ ENABLE?¨°DISABLE
  29   1        TIM_InitStructure.TIM_Value     = 65536UL - (MAIN_Fosc / 500);       //5MS 
  30   1        TIM_InitStructure.TIM_Run       = ENABLE;       //ÔËÐÐ ENABLE?¨°DISABLE
  31   1        Timer_Inilize(Timer1,&TIM_InitStructure);       //  ¶¨Ê±Æ÷1 Timer0,Timer1,Timer2
  32   1      
  33   1        TIM_InitStructure.TIM_Interrupt = ENABLE;       //ÖÐ¶ÏÊÇ·ñÔÊÐí,   ENABLE»òDISABLE. (×¢Òâ: Timer2¹Ì¶¨Îª16Î»×
             -Ô¶¯ÖØ×°, ÖÐ¶Ï¹Ì¶¨ÎªµÍÓÅÏÈ¼¶)
  34   1        TIM_InitStructure.TIM_ClkSource = TIM_CLOCK_12T;    //Ö¸¶¨Ê±ÖÓÔ´,     TIM_CLOCK_1T,TIM_CLOCK_12T,TIM_CLOCK_
             -Ext
  35   1        TIM_InitStructure.TIM_ClkOut    = DISABLE;;       //ÊÇ·ñÊä³ö¸ßËÙÂö³å, ENABLE»òDISABLE
  36   1        TIM_InitStructure.TIM_Value     = 65536UL - (MAIN_Fosc / (100));    //³õÖµ
  37   1        TIM_InitStructure.TIM_Run       = ENABLE;       //ÊÇ·ñ³õÊ¼»¯ºóÆô¶¯¶¨Ê±Æ÷, ENABLE»òDISABLE
  38   1        Timer_Inilize(Timer2,&TIM_InitStructure);       //³õÊ¼»¯Timer2    Timer0,Timer1,Timer2
  39   1        
  40   1        TIM_InitStructure.TIM_Interrupt = ENABLE;       //  ENABLE?¨°DISABLE.  
  41   1        TIM_InitStructure.TIM_ClkSource = TIM_CLOCK_12T;    //  TIM_CLOCK_1T,TIM_CLOCK_12T,TIM_CLOCK_Ext
  42   1        TIM_InitStructure.TIM_ClkOut    = DISABLE;        // ENABLE?¨°DISABLE
  43   1        TIM_InitStructure.TIM_Value     = 65536UL - (MAIN_Fosc / (100));    // 120MS
  44   1        TIM_InitStructure.TIM_Run       = ENABLE;       //  ENABLE?¨°DISABLE
  45   1        Timer_Inilize(Timer0,&TIM_InitStructure);       //   Timer0,Timer1,Timer2
  46   1      }
  47          
  48          //ÈÎÎñÊ±¼ä·ÖÆ¬
  49          u8 timer10ms=0;
  50          u8 timer200ms=0;
  51          /********************* Timer0ÖÐ¶Ïº¯Êý************************/
C51 COMPILER V9.60.0.0   TIMER                                                             05/19/2020 12:05:04 PAGE 2   

  52          //void timer0_int (void) interrupt TIMER0_VECTOR
  53          //{
  54          //  timer10ms++;
  55          //  if(timer10ms/20)
  56          //  {
  57          //    timer10ms=0;
  58          //    timer200ms++;
  59          //    TaskStateScanFlag=1;//»ù´¡ÈÎÎñ£¬Ô¼200msÔÊÐíÒ»´Î
  60          //  }
  61          //  
  62          //  if(MasterDataBuff[20] !=0 )//ÔÊÐíÉÏ´«
  63          //  {
  64          //    if(timer200ms >= MasterDataBuff[20])
  65          //      TaskUploadFlag=1;//ÉÏ´«ÈÎÎñ
  66          //  }
  67          //  else  timer200ms=0;
  68          
  69          //}
  70          
  71          
  72          /////********************* Timer0ÖÐ¶Ïº¯Êý************************/
  73           void timer0_int (void) interrupt TIMER0_VECTOR
  74           {
  75   1        //TaskUartFlag++;
  76   1        T0_100MS1++;
  77   1      
  78   1        if(T0_100MS1>=10)
  79   1        {
  80   2          T0_100MS1=0;
  81   2          T0_500MS2++;
  82   2          TaskStateScanFlag=1;
  83   2          if(T0_500MS2>=5)
  84   2          {
  85   3           T0_500MS2=0;
  86   3          }
  87   2          
  88   2         }
  89   1          
  90   1       
  91   1       }
  92          
  93          /********************* Timer1ÖÐ¶Ïº¯Êý************************/
  94          void timer1_int (void) interrupt TIMER1_VECTOR
  95          { 
  96   1        
  97   1        TaskUartFlag=1;
  98   1        TH1=(u8)(65536UL - (MAIN_Fosc / 200))/256;
  99   1        TL1=(u8)(65536UL - (MAIN_Fosc / 200))%256;
 100   1        
 101   1       TR1 = 0;
 102   1      //  T1_1MS1++;
 103   1      //  T1_10MS2++;
 104   1      //   
 105   1      //  if(T1_10MS2>=10)//1
 106   1      //    {
 107   1      //       T1_10MS2=0;
 108   1      //       
 109   1      //      
 110   1      //    }
 111   1      //  if ((T1_1MS1)>=100)     //MilliSecond
 112   1      //  { 
 113   1      //  
C51 COMPILER V9.60.0.0   TIMER                                                             05/19/2020 12:05:04 PAGE 3   

 114   1      //    T1_1MS1=0;     //1MS Timer
 115   1      //    
 116   1      //  }
 117   1      //  if(COM1.RcvFlag==1)
 118   1      //   {
 119   1      //     if (COM1.RX_TimeOut >0)    //==
 120   1      //    {
 121   1      //      --COM1.RX_TimeOut;
 122   1      //      if(COM1.RX_TimeOut==0)//½ÓÊÕÍêÒ»Ö¡
 123   1      //      {
 124   1      //       COM1.RcvFlag=0;
 125   1      //       COM1.RX_Cnt=0;
 126   1      //       RX1_Buffer[COM1.RX_Cnt]=0;
 127   1      //      }
 128   1      //    }
 129   1      //    
 130   1      //   }
 131   1        
 132   1      }
 133          
 134          
 135          /********************* Timer2ÖÐ¶Ïº¯Êý************************/
 136          //void timer2_int (void) interrupt TIMER2_VECTOR  
 137          //{
 138          //    if(T2_10MS2>=10)
 139          //  {
 140          //     T2_10MS2=0;
 141          //   } 
 142          //     
 143          //  // }
 144          //  
 145          
 146          //}
 147          
 148          
 149          
 150          //========================================================================
 151          // º¯Êý: u8 Timer_Inilize(u8 TIM, TIM_InitTypeDef *TIMx)
 152          // ÃèÊö: ¶¨Ê±Æ÷³õÊ¼»¯³ÌÐò.
 153          // ²ÎÊý: TIMx: ½á¹¹²ÎÊý,Çë²Î¿¼timer.hÀïµÄ¶¨Òå.
 154          // ·µ»Ø: ³É¹¦·µ»Ø0, ¿Õ²Ù×÷·µ»Ø1,´íÎó·µ»Ø2.
 155          // °æ±¾: V1.1, 2020-5-7
 156          //========================================================================
 157          u8  Timer_Inilize(u8 TIM, TIM_InitTypeDef *TIMx)
 158          {
 159   1        if(TIM > Timer2)  return 1; //¿Õ²Ù×÷
 160   1      
 161   1        if(TIM == Timer0)
 162   1        {
 163   2          TR0 = 0;    //Í£Ö¹¼ÆÊý
 164   2          if(TIMx->TIM_Interrupt == ENABLE)   ET0 = 1;  //ÔÊÐíÖÐ¶Ï
 165   2          else                  ET0 = 0;  //½ûÖ¹ÖÐ¶Ï
 166   2          if(TIMx->TIM_Polity == PolityHigh)    PT0 = 1;  //¸ßÓÅÏÈ¼¶ÖÐ¶Ï
 167   2          else                  PT0 = 0;  //µÍÓÅÏÈ¼¶ÖÐ¶Ï
 168   2          if(TIMx->TIM_Mode >  TIM_16BitAutoReloadNoMask) return 2; //´íÎó
 169   2          TMOD = (TMOD & ~0x03) | TIMx->TIM_Mode; //¹¤×÷Ä£Ê½,0: 16Î»×Ô¶¯ÖØ×°, 1: 16Î»¶¨Ê±/¼ÆÊý, 2: 8Î»×Ô¶¯ÖØ×°, 3:
             - 16Î»×Ô¶¯ÖØ×°, ²»¿ÉÆÁ±ÎÖÐ¶Ï
 170   2          if(TIMx->TIM_ClkSource == TIM_CLOCK_12T)  AUXR &= ~0x80;  //¶¨Ê±Æ÷0µÄËÙ¶ÈÊÇ´«Í³8051µÄ12±¶£¬²»·ÖÆµ£¨12T£©
 171   2          if(TIMx->TIM_ClkSource == TIM_CLOCK_1T)   AUXR |=  0x80;  //¶¨Ê±Æ÷1ÊÇ´«Í³8051ËÙ¶È£¬12·ÖÆµ(1T)  AUXR(¸¨Öú¼Ä
             -´æÆ÷)
 172   2          if(TIMx->TIM_ClkSource == TIM_CLOCK_Ext)  TMOD |=  0x04;  //¶ÔÍâ¼ÆÊý»ò·ÖÆµ
 173   2          else                    TMOD &= ~0x04;  //¶¨Ê±
C51 COMPILER V9.60.0.0   TIMER                                                             05/19/2020 12:05:04 PAGE 4   

 174   2          if(TIMx->TIM_ClkOut == ENABLE)  INT_CLKO |=  0x01;  //Êä³öÊ±ÖÓ
 175   2          else              INT_CLKO &= ~0x01;  //²»Êä³öÊ±ÖÓ
 176   2          
 177   2          TH0 = (u8)(TIMx->TIM_Value >> 8);
 178   2          TL0 = (u8)TIMx->TIM_Value;
 179   2          if(TIMx->TIM_Run == ENABLE) TR0 = 1;  //¿ªÊ¼ÔËÐÐ
 180   2          return  0;    //³É¹¦
 181   2        }
 182   1      
 183   1        if(TIM == Timer1)
 184   1        {
 185   2          TR1 = 0;    //Í£Ö¹¼ÆÊý
 186   2          if(TIMx->TIM_Interrupt == ENABLE)   ET1 = 1;  //ÔÊÐíÖÐ¶Ï
 187   2          else                  ET1 = 0;  //½ûÖ¹ÖÐ¶Ï
 188   2          if(TIMx->TIM_Polity == PolityHigh)    PT1 = 1;  //¸ßÓÅÏÈ¼¶ÖÐ¶Ï
 189   2          else                  PT1 = 0;  //µÍÓÅÏÈ¼¶ÖÐ¶Ï
 190   2          if(TIMx->TIM_Mode >= TIM_16BitAutoReloadNoMask) return 2; //´íÎó
 191   2          TMOD = (TMOD & ~0x30) | TIMx->TIM_Mode; //¹¤×÷Ä£Ê½,0: 16Î»×Ô¶¯ÖØ×°, 1: 16Î»¶¨Ê±/¼ÆÊý, 2: 8Î»×Ô¶¯ÖØ×°
 192   2          if(TIMx->TIM_ClkSource == TIM_CLOCK_12T)  AUXR &= ~0x40;  //12T
 193   2          if(TIMx->TIM_ClkSource == TIM_CLOCK_1T)   AUXR |=  0x40;  //1T
 194   2          if(TIMx->TIM_ClkSource == TIM_CLOCK_Ext)  TMOD |=  0x40;  //¶ÔÍâ¼ÆÊý»ò·ÖÆµ
 195   2          else                    TMOD &= ~0x40;  //¶¨Ê±
 196   2          if(TIMx->TIM_ClkOut == ENABLE)  INT_CLKO |=  0x02;  //Êä³öÊ±ÖÓ
 197   2          else              INT_CLKO &= ~0x02;  //²»Êä³öÊ±ÖÓ
 198   2          
 199   2          TH1 = (u8)(TIMx->TIM_Value >> 8);
 200   2          TL1 = (u8)TIMx->TIM_Value;
 201   2          if(TIMx->TIM_Run == ENABLE) TR1 = 1;  //¿ªÊ¼ÔËÐÐ
 202   2          return  0;    //³É¹¦
 203   2        }
 204   1      
 205   1        if(TIM == Timer2)   //Timer2,¹Ì¶¨Îª16Î»×Ô¶¯ÖØ×°, ÖÐ¶ÏÎÞÓÅÏÈ¼¶
 206   1        {
 207   2          AUXR &= ~(1<<4);  //Í£Ö¹¼ÆÊý
 208   2          if(TIMx->TIM_Interrupt == ENABLE)     IE2  |=  (1<<2);  //ÔÊÐíÖÐ¶Ï
 209   2          else                    IE2  &= ~(1<<2);  //½ûÖ¹ÖÐ¶Ï
 210   2          if(TIMx->TIM_ClkSource >  TIM_CLOCK_Ext)  return 2;
 211   2          if(TIMx->TIM_ClkSource == TIM_CLOCK_12T)  AUXR &= ~(1<<2);  //12T
 212   2          if(TIMx->TIM_ClkSource == TIM_CLOCK_1T)   AUXR |=  (1<<2);  //1T
 213   2          if(TIMx->TIM_ClkSource == TIM_CLOCK_Ext)  AUXR |=  (1<<3);  //¶ÔÍâ¼ÆÊý»ò·ÖÆµ
 214   2          else                    AUXR &= ~(1<<3);  //¶¨Ê±
 215   2          if(TIMx->TIM_ClkOut == ENABLE)  INT_CLKO |=  0x04;  //Êä³öÊ±ÖÓ
 216   2          else              INT_CLKO &= ~0x04;  //²»Êä³öÊ±ÖÓ
 217   2      
 218   2          TH2 = (u8)(TIMx->TIM_Value >> 8);
 219   2          TL2 = (u8)TIMx->TIM_Value;
 220   2          if(TIMx->TIM_Run == ENABLE) AUXR |=  (1<<4);  //¿ªÊ¼ÔËÐÐ
 221   2          return  0;    //³É¹¦
 222   2        }
 223   1        return 2; //´íÎó
 224   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    674    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      8       8
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.

C51 COMPILER V9.60.0.0   TIMER                                                             05/19/2020 12:05:04 PAGE 5   


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
