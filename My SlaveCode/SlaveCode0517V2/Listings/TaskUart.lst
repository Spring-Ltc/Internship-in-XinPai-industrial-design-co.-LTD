C51 COMPILER V9.54   TASKUART                                                              05/19/2020 11:32:55 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE TASKUART
OBJECT MODULE PLACED IN .\Objects\TaskUart.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Spring Program Files(x86)\MDK4 and MDK5\C51\BIN\C51.EXE USER\TaskUart.c LARG
                    -E ROM(COMPACT) OPTIMIZE(8,SPEED) BROWSE INCDIR(.\USER;.\FWLIB) DEBUG OBJECTEXTEND PRINT(.\Listings\TaskUart.lst) TABS(2)
                    - OBJECT(.\Objects\TaskUart.obj)

line level    source

   1          
   2          
   3          
   4          #include "TaskUart.h"
   5          #include "USART.h"
   6          
   7          
   8          
   9          
  10          
  11          
  12          u8 ReceiveBuff[MaxReceiveLen];
  13          //Ê¹ÓÃµÄUSART1£¬¶¨Ê±Æ÷Timer2×÷Îª²¨ÌØÂÊ·¢ÉúÆ÷
  14          void TaskUart1_Init(u16 bound)
  15          {
  16   1        COMx_InitDefine   COMx_InitStructure;         //½á¹¹¶¨Òå
  17   1        COMx_InitStructure.UART_Mode      = UART_8bit_BRTx;   //Ä£Ê½,       UART_ShiftRight,UART_8bit_BRTx,UART_9b
             -it,UART_9bit_BRTx
  18   1        COMx_InitStructure.UART_BRT_Use   = BRT_Timer2;//Ê¹ÓÃ²¨ÌØÂÊ,   BRT_Timer1, BRT_Timer2 (×¢Òâ: ´®¿Ú2¹Ì¶¨Ê¹Ó
             -ÃBRT_Timer2)
  19   1        COMx_InitStructure.UART_BaudRate  = 115200ul;     //²¨ÌØÂÊ,     110 ~ 115200
  20   1        COMx_InitStructure.UART_RxEnable  = ENABLE;       //½ÓÊÕÔÊĞí,   ENABLE»òDISABLE
  21   1        COMx_InitStructure.BaudRateDouble = DISABLE;      //²¨ÌØÂÊ¼Ó±¶, ENABLE?DISABLE
  22   1        COMx_InitStructure.UART_Interrupt = ENABLE;       //ÖĞ¶ÏÔÊĞí,   ENABLE»òDISABLE
  23   1        COMx_InitStructure.UART_Polity    = PolityHigh;     //ÖĞ¶ÏÓÅÏÈ¼¶, PolityLow,PolityHigh
  24   1        COMx_InitStructure.UART_P_SW      = UART1_SW_P36_P37; //ÇĞ»»¶Ë¿Ú,  
  25   1        COMx_InitStructure.UART_RXD_TXD_Short = DISABLE;    //ÄÚ²¿¶ÌÂ·RXDÓëTXD, ×öÖĞ¼Ì, ENABLE,DISABLE
  26   1        USART_Configuration(USART1, &COMx_InitStructure);   //³õÊ¼»¯´®¿Ú1 
  27   1      }
*** WARNING C280 IN LINE 14 OF USER\TaskUart.c: 'bound': unreferenced local variable
  28          
  29          
  30          u8 ReceiveEnable=0;//×´Ì¬»ú×´Ì¬±êÖ¾
  31          u8 ReceiveCount=0;
  32          //²ÉÓÃ×´Ì¬»úµÄ·½Ê½
  33          /********************* UART1ÖĞ¶Ïº¯Êı************************/
  34          void UART1_int (void) interrupt UART1_VECTOR
  35          {
  36   1        u8 res;
  37   1        if(RI)//½ÓÊÕÖĞ¶Ï±êÖ¾Î»
  38   1        {
  39   2          res = SBUF;
  40   2          ReceiveBuff[ReceiveCount++] = res;//´æµ½»º´æÇø
  41   2          
  42   2          if(ReceiveCount>36)
  43   2            ReceiveCount=36;//±ÜÃâÊı×éÒç³ö
  44   2          
  45   2          if(ReceiveEnable != 2)  //×´Ì¬£º¶¨Ê±Æ÷Î´´ò¿ª
  46   2          {
  47   3            ReceiveCount=0;
  48   3            switch (ReceiveEnable)
  49   3            {
  50   4              case 0://Î´ÊÕµ½AA
C51 COMPILER V9.54   TASKUART                                                              05/19/2020 11:32:55 PAGE 2   

  51   4              {
  52   5                if(res == 0xAA)
  53   5                  ReceiveEnable = 1;
  54   5                break;
  55   5              }
  56   4              case 1://ÊÕµ½AA
  57   4              {
  58   5                if(res == 0x55)
  59   5                {
  60   6                  ReceiveEnable =2;
  61   6                  ReceiveBuff[0]=0xAA,ReceiveBuff[1]=0x55;//È·ÈÏÊÕµ½Í·²¿£¬ÊÖ¶¯Ìí¼Óµ½»º´æÊı×é
  62   6                  ReceiveCount=2;//ÏÂÒ»¸öÊı¾İ´ÓRX1_Buffer[2]¿ªÊ¼»º´æ
  63   6                  TR1 = 1;//¡¾¿ª¶¨Ê±Æ÷1¡¿
  64   6                }
  65   5                else if(res == 0xAA)  ReceiveEnable = 1;
  66   5                else ReceiveEnable = 0;
  67   5                break;
  68   5              }
  69   4              default:  break;
  70   4            }
  71   3          }
  72   2          RI=0;//ÇåÖĞ¶Ï±êÖ¾Î»£¬×¼±¸½ÓÊÕÏÂÒ»¸ö×Ö½Ú
  73   2        }
  74   1      }
  75          
  76          
  77          
  78          
  79          
  80          //--------------------------º¯ÊıËµÃ÷--------------------------------------------//
  81          //º¯Êı¹¦ÄÜ£º  Íê³É¶ÔÊı¾İÖ¡µÄĞ£Ñé
  82          //Èë¿Ú²ÎÊı£º  *DATaFrame:´ıĞ£ÑéµÄÊı¾İÖ¡µØÖ·
  83          //·µ»ØÖµ£º  ·µ»Ø0±íÊ¾Ğ£Ñé³É¹¦£¬·µ»ØÆäËûÖµ±íÊ¾Ğ£ÑéÊ§°Ü
  84          //                      £¨1:°üÍ·´íÎó£»2:°üÎ²»ò³¤¶È´íÎó£»3:Ğ£ÑéºÍ´íÎó£©
  85          
  86          //-------------------------º¯Êı²âÊÔ----------------------------------------//
  87          //text1£ºÊäÈë£ºAA 55 06 20 21 00 58 FF FF 5F 55 AA    ·µ»ØÖµ£º0   ËµÃ÷£ºÊı¾İÖ¡Ğ£Ñé³É¹¦
  88          //text2£ºÊäÈë£ºAA 55 06 20 21 00 58 FF FF 11 55 AA    ·µ»ØÖµ£º3   ËµÃ÷£ºĞ£ÑéºÍ´íÎó
  89          //text3£ºÊäÈë£ºAA 06 20 21 00 58 FF FF 5F 55 AA       ·µ»ØÖµ£º1   ËµÃ÷£º°üÍ·´íÎó
  90          //text4£ºÊäÈë£ºAA 55 06 20 21 00 58 FF FF 5F 55       ·µ»ØÖµ£º2   ËµÃ÷£º°üÎ²´íÎó
  91          //text5£ºÊäÈë£ºAA 55 04 20 21 00 58 FF FF 5F 55 AA    ·µ»ØÖµ£º2   ËµÃ÷£ºÊı¾İ³¤¶È´íÎó
  92          //--------------------------------
  93          //×÷Õß£ºLiao_tingchun   
  94          //ĞŞ¸ÄÈÕÆÚ£º2020/05/15
  95          //ĞŞ¸ÄÄÚÈİ£º³õ´ÎÍê³É»ù±¾¹¦ÄÜ
  96          //----------------------------
  97          u8 DataValidityCheck(u8 *DataFrame)
  98          {
  99   1        u8 i = 0,datalen = 0,Parity = 0;
 100   1        u8 *point;
 101   1        point = DataFrame;
 102   1        if( (*(point) != 0xAA) || (*(point+1) != 0x55))
 103   1          return 1;//Êı¾İ°üÍ·´íÎó
 104   1        
 105   1        datalen = *(point+2);//»ñÈ¡Êı¾İ²¿·Ö³¤¶È
 106   1        if( (*(point+datalen+4) != 0x55) || (*(point+datalen+5) != 0xAA))
 107   1          return 2;//Êı¾İ°üÎ²´íÎó
 108   1        
 109   1        Parity = datalen;
 110   1        for(i=3;i<datalen+3;i++)//¼ÆËãĞ£ÑéºÍ
 111   1          Parity =Parity ^ *(point+i);//°´Î»Òì»òÔËËã
 112   1        if(Parity != *(point+datalen+3))
C51 COMPILER V9.54   TASKUART                                                              05/19/2020 11:32:55 PAGE 3   

 113   1          return 3;//Ğ£ÑéºÍ´íÎó
 114   1        
 115   1        return 0;//Ğ£Ñé³É¹¦
 116   1      }
 117          
 118          
 119          
 120          //--------------------------º¯ÊıËµÃ÷--------------------------------------------//
 121          //º¯Êı¹¦ÄÜ£º  Êı¾İĞ£Ñé³É¹¦ºó£¬´Ó¿Ø°åµ÷ÓÃ¸Ãº¯Êı½âÎöÊı¾İ
 122          //Èë¿Ú²ÎÊı£º  *DataBuff:ĞèÒª½âÎöµÄÊı¾İÖ¡µØÖ·
 123          //·µ»ØÖµ£º    ÎŞ
 124          
 125          //--------------------------------
 126          //×÷Õß£ºLiao_tingchun   
 127          //ĞŞ¸ÄÈÕÆÚ£º2020/05/16
 128          //ĞŞ¸ÄÄÚÈİ£º³õ´ÎÍê³É»ù±¾¹¦ÄÜ
 129          //----------------------------
 130          void DataAnalyze(u8 *DataBuff)
 131          {
 132   1        u8 i=0;
 133   1        u8 *point;
 134   1        u8 data_H,data_L;
 135   1        u8 FunctionCode = *(point+6);//¹¦ÄÜÂë
 136   1        point = DataBuff;
 137   1        switch(FunctionCode)
 138   1        {
 139   2          case 0x5B://Ö÷¿Ø°åÖÁ´Ó¿Ø°åµÄ¿ØÖÆĞÅÏ¢
 140   2          {
 141   3            for(i=0;i<6;i++)
 142   3              MasterDataBuff[i] = *(point+7+i);//Ğ´Èë6¸öLEDµÄ¿ØÖÆ×´Ì¬
 143   3            for(i=0;i<7;i++)
 144   3              MasterDataBuff[i+12] = *(point+19+i);//Ğ´Èë7¸ö¼ÌµçÆ÷µÄ¿ØÖÆ×´Ì¬
 145   3            for(i=0;i<3;i++)
 146   3              MasterDataBuff[i+23] = *(point+30+i);//Ê¹ÄÜ3¸ö¿×Î»      
 147   3            TaskControlFlag = 1;
 148   3            break;
 149   3          }
 150   2          case 0x5C://ÉèÖÃÏŞÖÆ³éÒº´ÎÊı
 151   2          {
 152   3            data_H = *(point+7);
 153   3            data_L = *(point+8);
 154   3            MasterDataBuff[21] = data_H;MasterDataBuff[22] = data_L;//EEPROMÈÎÎñ´ÓÕâÀï¶ÁÈ¡²¢Ğ´Èë£¬Íê³ÉÉèÖÃ
 155   3            TaskEEPROMFlag = 1;//±êÖ¾Î»ÖÃÎ»£¬EEPROMÈÎÎñĞ´ÈëÍê³ÉºóÇå±êÖ¾Î»
 156   3            break;
 157   3          }
 158   2          case 0x5D://Ñ¯ÎÊÊ£ÓàÏŞÖÆ´ÎÊı
 159   2          {
 160   3            FramePacking(0x70,&SlaveDataBuff [21]);//Ö±½ÓÉÏ´«
 161   3            //TaskUploadFlag = 1;//ÖÃÎ»¸ÃÉÏ´«ÈÎÎñ
 162   3            break;
 163   3          }
 164   2          case 0x5E://²éÑ¯¹¤×÷×´Ì¬
 165   2          {
 166   3            TaskUploadFlag = 1;//ÖÃÎ»¸ÃÉÏ´«ÈÎÎñ
 167   3            break;
 168   3          }
 169   2          case 0x60://ÉèÖÃÉÏ´«Ê±¼ä¼ä¸ô
 170   2          {
 171   3            data_H = *(point+7);
 172   3            data_L = *(point+8);  //Ö»ÓÃµ½ÁËµÍ8Î»Êı¾İ
 173   3            SlaveDataBuff[20] = data_L;//±¾µØ±£´æÊ±¼ä¼ä¸ô
 174   3            MasterDataBuff[20] = data_L;
C51 COMPILER V9.54   TASKUART                                                              05/19/2020 11:32:55 PAGE 4   

 175   3            break;
 176   3          }
 177   2          default:break;
 178   2        } 
 179   1      }
 180          
 181          
 182          //--------------------------º¯ÊıËµÃ÷--------------------------------------------//
 183          //º¯Êı¹¦ÄÜ£º  ½«Êı¾İ°´ÕÕĞ­Òé´ò°ü³ÉÖ¡²¢·¢ËÍ
 184          //Èë¿Ú²ÎÊı£º  FunctionCode:¹¦ÄÜÂë
 185          //            *DataBuff:ĞèÒª·¢ËÍµÄÊı¾İÇøµÄÄÚÈİ
 186          //·µ»ØÖµ£º    ÎŞ
 187          
 188          //--------------------------------
 189          //×÷Õß£ºLiao_tingchun   
 190          //ĞŞ¸ÄÈÕÆÚ£º2020/05/16
 191          //ĞŞ¸ÄÄÚÈİ£º³õ´ÎÍê³É»ù±¾¹¦ÄÜ
 192          //----------------------------
 193          void FramePacking(u8 FunctionCode,u8 *DataBuff)
 194          {
 195   1      
 196   1        u8 DataLen;//Êı¾İÇø³¤¶È,Ö¸ÓĞĞ§µÄÊı¾İ³¤¶È£¬²»°üº¬Éè±¸±àÂëºÍ¹¦ÄÜÂë
 197   1        u8 *point = DataBuff;
 198   1        u8 Parity;
 199   1        u8 i=0; //Êı¾İ´®ÏÂ±ê
 200   1        u8 SendStr[MaxSendStr] =    //ÏÂÃæÖ»»º´æµ½Ğ£ÑéÎ»Ö®Ç°
 201   1                          {0xAA,0x55,//Êı¾İ°üÍ·
 202   1                          0xFF,//Êı¾İ¶Î³¤¶È¡¾MCUµÄÎÊÌâÂğ£¿³õÊ¼»¯²»ÄÜÓÃ±äÁ¿¸³Öµ£¬ºóÃæÖØĞ´Ò»´Î°É¡¿
 203   1                          0x21,0x20,//·¢ËÍºÍ½ÓÊÕ·½Ê¶±ğÂë
 204   1                          0x00,//ÊÇ·ñĞèÒªÓ¦´ğ
 205   1                          0xFF//¹¦ÄÜÂë£¬ÓÉ×ÜĞ­ÒéÎÄµµ¹æ¶¨¡¾MCUµÄÎÊÌâÂğ£¿³õÊ¼»¯²»ÄÜÓÃ±äÁ¿¸³Öµ£¬ºóÃæÖØĞ´Ò»´Î°É¡¿
 206   1                          };
 207   1        if(FunctionCode == 0x70)  DataLen =2;
 208   1        else if(FunctionCode == 0x71) DataLen =23;  
 209   1        SendStr[2] = DataLen+4;//ÖØĞÂ°Ñ³¤¶ÈĞ´µ½Êı¾İÖ¡ÀïÃæ£¬+4
 210   1        SendStr[6] = FunctionCode;//ÖØĞÂ°Ñ¹¦ÄÜÂëĞ´µ½Êı¾İÖ¡ÀïÃæ                
 211   1        for(i=0;i<DataLen;i++)              
 212   1              SendStr[i+7] = *(point+i);  //Ìí¼ÓÊı¾İÇø  
 213   1                          
 214   1        Parity = SendStr[2];
 215   1        for(i=3;i<SendStr[2]+3;i++)//¼ÆËãĞ£ÑéÊı¾İ
 216   1          Parity = Parity^SendStr[i];//°´Î»Òì»òÔËËã
 217   1                          
 218   1        SendStr[i]=Parity;i++;//Ìí¼ÓĞ£ÑéÊı¾İ
 219   1        SendStr[i]=0x55;i++;
 220   1        SendStr[i]=0xAA;i++;//Ìí¼ÓÊı¾İ°üÎ²²¿
 221   1      //Êı¾İÖ¡´ò°üÍê±Ï
 222   1      
 223   1        SendDataLen(SendStr,DataLen+10);//·¢ËÍÊı¾İ°ü
 224   1      }
 225          
 226          
 227          /**************************************************************************
 228          ¹¦ÄÜ£ºSTC15µ¥Æ¬»úµÄ´®¿Ú·¢ËÍ×Ö½ÚµÄº¯Êı
 229          ²ÎÊı£ºdat:Òª·¢ËÍµÄÒ»¸ö×Ö½Ú   
 230          **************************************************************************/
 231          void UART_Send_Byte(unsigned char dat)
 232          {
 233   1          ES=0;    // Ê¹ÓÃ²éÑ¯·¢ËÍ½áÊø·½Ê½£¬½ûÖ¹ÖĞ¶Ï¸ÉÔ¤  ES ´®ĞĞÖĞ¶Ï ÔÊĞíÎ»
 234   1          SBUF = dat;
 235   1          while(!TI);     
 236   1          TI=0;  //´Ë¾ä¿ÉÒÔ²»Òª£¬²»Ó°ÏìºóÃæÊı¾İµÄ·¢ËÍ£¬Ö»¹©´úÂë²éÑ¯Êı¾İÊÇ·ñ·¢ËÍÍê³É
C51 COMPILER V9.54   TASKUART                                                              05/19/2020 11:32:55 PAGE 5   

 237   1          ES=1;
 238   1      } 
 239          
 240          
 241          
 242          
 243          void SendDataLen(u8 *DataBuff,u8 len)
 244          {
 245   1        u8 i=0;
 246   1        u8 *point = DataBuff;
 247   1        for(i=0;i<len;i++)
 248   1        {
 249   2          UART_Send_Byte(*(point+i));
 250   2        }
 251   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1059    ----
   CONSTANT SIZE    =     35    ----
   XDATA SIZE       =     42      73
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
