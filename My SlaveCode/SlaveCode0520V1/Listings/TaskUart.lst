C51 COMPILER V9.54   TASKUART                                                              05/20/2020 10:08:50 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE TASKUART
OBJECT MODULE PLACED IN .\Objects\TaskUart.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Spring Program Files(x86)\MDK4 and MDK5\C51\BIN\C51.EXE USER\TaskUart.c COMP
                    -ACT ROM(COMPACT) OPTIMIZE(8,SPEED) BROWSE INCDIR(.\USER;.\FWLIB) DEBUG OBJECTEXTEND PRINT(.\Listings\TaskUart.lst) TABS(
                    -2) OBJECT(.\Objects\TaskUart.obj)

line level    source

   1          
   2          
   3          
   4          #include "TaskUart.h"
   5          #include "USART.h"
   6          
   7          
   8          
   9          
  10          
  11          
  12          u8 ReceiveBuff[MaxReceiveLen];
  13          //Ê¹ÓÃµÄUSART1£¬¶¨Ê±Æ÷Timer2×÷Îª²¨ÌØÂÊ·¢ÉúÆ÷
  14          void TaskUart1_Init(void)
  15          {
  16   1        COMx_InitDefine   COMx_InitStructure;         //½á¹¹¶¨Òå
  17   1        COMx_InitStructure.UART_Mode      = UART_8bit_BRTx;   //Ä£Ê½,       UART_ShiftRight,UART_8bit_BRTx,UART_9b
             -it,UART_9bit_BRTx
  18   1        COMx_InitStructure.UART_BRT_Use   = BRT_Timer2;//Ê¹ÓÃ²¨ÌØÂÊ,   BRT_Timer1, BRT_Timer2 (×¢Òâ: ´®¿Ú2¹Ì¶¨Ê¹Ó
             -ÃBRT_Timer2)
  19   1        COMx_InitStructure.UART_BaudRate  = 115200ul;     //²¨ÌØÂÊ,     110 ~ 115200
  20   1        COMx_InitStructure.UART_RxEnable  = ENABLE;       //½ÓÊÕÔÊÐí,   ENABLE»òDISABLE
  21   1        COMx_InitStructure.BaudRateDouble = DISABLE;      //²¨ÌØÂÊ¼Ó±¶, ENABLE?DISABLE
  22   1        COMx_InitStructure.UART_Interrupt = ENABLE;       //ÖÐ¶ÏÔÊÐí,   ENABLE»òDISABLE
  23   1        COMx_InitStructure.UART_Polity    = PolityHigh;     //ÖÐ¶ÏÓÅÏÈ¼¶, PolityLow,PolityHigh
  24   1        COMx_InitStructure.UART_P_SW      = UART1_SW_P36_P37; //ÇÐ»»¶Ë¿Ú,  
  25   1        COMx_InitStructure.UART_RXD_TXD_Short = DISABLE;    //ÄÚ²¿¶ÌÂ·RXDÓëTXD, ×öÖÐ¼Ì, ENABLE,DISABLE
  26   1        USART_Configuration(USART1, &COMx_InitStructure);   //³õÊ¼»¯´®¿Ú1 
  27   1      }
  28          
  29          
  30          u8 ReceiveEnable=0;//×´Ì¬»ú×´Ì¬±êÖ¾
  31          u8 ReceiveCount=0;
  32          //²ÉÓÃ×´Ì¬»úµÄ·½Ê½
  33          /********************* UART1ÖÐ¶Ïº¯Êý************************/
  34          void UART1_int (void) interrupt UART1_VECTOR
  35          {
  36   1        u8 res;
  37   1        if(RI)//½ÓÊÕÖÐ¶Ï±êÖ¾Î»
  38   1        {
  39   2          res = SBUF;
  40   2          ReceiveBuff[ReceiveCount++] = res;//´æµ½»º´æÇø
  41   2            
  42   2          if(ReceiveEnable != 2)  //×´Ì¬£º¶¨Ê±Æ÷Î´´ò¿ª
  43   2          {
  44   3            ReceiveCount=0;
  45   3            switch (ReceiveEnable)
  46   3            {
  47   4              case 0://Î´ÊÕµ½AA
  48   4              {
  49   5                if(res == 0xAA)
  50   5                  ReceiveEnable = 1;
  51   5                break;
C51 COMPILER V9.54   TASKUART                                                              05/20/2020 10:08:50 PAGE 2   

  52   5              }
  53   4              case 1://ÊÕµ½AA
  54   4              {
  55   5                if(res == 0x55)
  56   5                {
  57   6                  ReceiveEnable =2;
  58   6                  ReceiveBuff[0]=0xAA,ReceiveBuff[1]=0x55;//È·ÈÏÊÕµ½Í·²¿£¬ÊÖ¶¯Ìí¼Óµ½»º´æÊý×é
  59   6                  ReceiveCount=2;//ÏÂÒ»¸öÊý¾Ý´ÓRX1_Buffer[2]¿ªÊ¼»º´æ
  60   6                  TR1 = 1;//¡¾¿ª¶¨Ê±Æ÷1¡¿
  61   6                }
  62   5                else if(res == 0xAA)  ReceiveEnable = 1;
  63   5                else ReceiveEnable = 0;
  64   5                break;
  65   5              }
  66   4              default:  break;
  67   4            }
  68   3          }
  69   2          RI=0;//ÇåÖÐ¶Ï±êÖ¾Î»£¬×¼±¸½ÓÊÕÏÂÒ»¸ö×Ö½Ú
  70   2        }
  71   1      }
  72          
  73          
  74          
  75          
  76          
  77          //--------------------------º¯ÊýËµÃ÷--------------------------------------------//
  78          //º¯Êý¹¦ÄÜ£º  Íê³É¶ÔÊý¾ÝÖ¡µÄÐ£Ñé
  79          //Èë¿Ú²ÎÊý£º  *DATaFrame:´ýÐ£ÑéµÄÊý¾ÝÖ¡µØÖ·
  80          //·µ»ØÖµ£º  ·µ»Ø0±íÊ¾Ð£Ñé³É¹¦£¬·µ»ØÆäËûÖµ±íÊ¾Ð£ÑéÊ§°Ü
  81          //                      £¨1:°üÍ·´íÎó£»2:°üÎ²»ò³¤¶È´íÎó£»3:Ð£ÑéºÍ´íÎó£©
  82          
  83          //-------------------------º¯Êý²âÊÔ----------------------------------------//
  84          //text1£ºÊäÈë£ºAA 55 06 20 21 00 58 FF FF 5F 55 AA    ·µ»ØÖµ£º0   ËµÃ÷£ºÊý¾ÝÖ¡Ð£Ñé³É¹¦
  85          //text2£ºÊäÈë£ºAA 55 06 20 21 00 58 FF FF 11 55 AA    ·µ»ØÖµ£º3   ËµÃ÷£ºÐ£ÑéºÍ´íÎó
  86          //text3£ºÊäÈë£ºAA 06 20 21 00 58 FF FF 5F 55 AA       ·µ»ØÖµ£º1   ËµÃ÷£º°üÍ·´íÎó
  87          //text4£ºÊäÈë£ºAA 55 06 20 21 00 58 FF FF 5F 55       ·µ»ØÖµ£º2   ËµÃ÷£º°üÎ²´íÎó
  88          //text5£ºÊäÈë£ºAA 55 04 20 21 00 58 FF FF 5F 55 AA    ·µ»ØÖµ£º2   ËµÃ÷£ºÊý¾Ý³¤¶È´íÎó
  89          //--------------------------------
  90          //×÷Õß£ºLiao_tingchun   
  91          //ÐÞ¸ÄÈÕÆÚ£º2020/05/15
  92          //ÐÞ¸ÄÄÚÈÝ£º³õ´ÎÍê³É»ù±¾¹¦ÄÜ
  93          //----------------------------
  94          u8 DataValidityCheck(u8 *DataFrame)
  95          {
  96   1        u8 i = 0,datalen = 0,Parity = 0;
  97   1        u8 *point;
  98   1        point = DataFrame;
  99   1        if( (*(point) != 0xAA) || (*(point+1) != 0x55))
 100   1          return 1;//Êý¾Ý°üÍ·´íÎó
 101   1        
 102   1        datalen = *(point+2);//»ñÈ¡Êý¾Ý²¿·Ö³¤¶È
 103   1        if( (*(point+datalen+4) != 0x55) || (*(point+datalen+5) != 0xAA))
 104   1          return 2;//Êý¾Ý°üÎ²´íÎó
 105   1        
 106   1        Parity = datalen;
 107   1        for(i=3;i<datalen+3;i++)//¼ÆËãÐ£ÑéºÍ
 108   1          Parity =Parity ^ *(point+i);//°´Î»Òì»òÔËËã
 109   1        if(Parity != *(point+datalen+3))
 110   1          return 3;//Ð£ÑéºÍ´íÎó
 111   1        
 112   1        return 0;//Ð£Ñé³É¹¦
 113   1      }
C51 COMPILER V9.54   TASKUART                                                              05/20/2020 10:08:50 PAGE 3   

 114          
 115          
 116          
 117          //--------------------------º¯ÊýËµÃ÷--------------------------------------------//
 118          //º¯Êý¹¦ÄÜ£º  Êý¾ÝÐ£Ñé³É¹¦ºó£¬´Ó¿Ø°åµ÷ÓÃ¸Ãº¯Êý½âÎöÊý¾Ý
 119          //Èë¿Ú²ÎÊý£º  *DataBuff:ÐèÒª½âÎöµÄÊý¾ÝÖ¡µØÖ·
 120          //·µ»ØÖµ£º    ÎÞ
 121          
 122          //--------------------------------
 123          //×÷Õß£ºLiao_tingchun   
 124          //ÐÞ¸ÄÈÕÆÚ£º2020/05/16
 125          //ÐÞ¸ÄÄÚÈÝ£º³õ´ÎÍê³É»ù±¾¹¦ÄÜ
 126          //----------------------------
 127          void DataAnalyze(u8 *DataBuff)
 128          {
 129   1        u8 i=0;
 130   1        u8 *point;
 131   1        u8 data_H,data_L;
 132   1        u8 FunctionCode = *(point+6);//¹¦ÄÜÂë
 133   1        point = DataBuff;
 134   1        switch(FunctionCode)
 135   1        {
 136   2          case 0x55://Ö÷¿Ø°åÖÁ´Ó¿Ø°åµÄ¿ØÖÆÐÅÏ¢
 137   2          {
 138   3            for(i=0;i<6;i++)
 139   3              MasterDataBuff[i] = *(point+7+i);//Ð´Èë6¸öLEDµÄ¿ØÖÆ×´Ì¬
 140   3            for(i=0;i<8;i++)
 141   3              MasterDataBuff[i+12] = *(point+19+i);//Ð´Èë8¸ö¼ÌµçÆ÷µÄ¿ØÖÆ×´Ì¬
 142   3            for(i=0;i<3;i++)
 143   3              MasterDataBuff[i+23] = *(point+30+i);//Ê¹ÄÜ3¸ö¿×Î»      
 144   3            TaskControlFlag = 1;
 145   3            break;
 146   3          }
 147   2          case 0x57://ÉèÖÃÏÞÖÆ³éÒº´ÎÊý
 148   2          {
 149   3            data_H = *(point+7);
 150   3            data_L = *(point+8);
 151   3            MasterDataBuff[MA_limit] = data_H;MasterDataBuff[MA_limit+1] = data_L;//EEPROMÈÎÎñ´ÓÕâÀï¶ÁÈ¡²¢Ð´Èë£¬Íê³
             -ÉÉèÖÃ
 152   3            TaskEEPROMFlag = 1;//±êÖ¾Î»ÖÃÎ»£¬EEPROMÈÎÎñÐ´ÈëÍê³ÉºóÇå±êÖ¾Î»
 153   3            break;
 154   3          }
 155   2          case 0x58://Ñ¯ÎÊÊ£ÓàÏÞÖÆ´ÎÊý
 156   2          {
 157   3            FramePacking(0x70,&ReceiveBuff[SA_limit]);//Ö±½ÓÉÏ´«
 158   3            //TaskUploadFlag = 1;//ÖÃÎ»¸ÃÉÏ´«ÈÎÎñ
 159   3            break;
 160   3          }
 161   2          case 0x59://²éÑ¯¹¤×÷×´Ì¬
 162   2          {
 163   3            TaskUploadFlag = 1;//ÖÃÎ»¸ÃÉÏ´«ÈÎÎñ
 164   3            break;
 165   3          }
 166   2          case 0x5A://ÉèÖÃÉÏ´«Ê±¼ä¼ä¸ô
 167   2          {
 168   3            data_H = *(point+7);
 169   3            data_L = *(point+8);  //Ö»ÓÃµ½ÁËµÍ8Î»Êý¾Ý
 170   3            SlaveDataBuff[SA_time] = data_L;//±¾µØ±£´æÊ±¼ä¼ä¸ô
 171   3            MasterDataBuff[MA_time] = data_L;
 172   3            break;
 173   3          }
 174   2          default:break;
C51 COMPILER V9.54   TASKUART                                                              05/20/2020 10:08:50 PAGE 4   

 175   2        } 
 176   1      }
 177          
 178          
 179          //--------------------------º¯ÊýËµÃ÷--------------------------------------------//
 180          //º¯Êý¹¦ÄÜ£º  ½«Êý¾Ý°´ÕÕÐ­Òé´ò°ü³ÉÖ¡²¢·¢ËÍ
 181          //Èë¿Ú²ÎÊý£º  FunctionCode:¹¦ÄÜÂë
 182          //            *DataBuff:ÐèÒª·¢ËÍµÄÊý¾ÝÇøµÄÄÚÈÝ
 183          //·µ»ØÖµ£º    ÎÞ
 184          
 185          //--------------------------------
 186          //×÷Õß£ºLiao_tingchun   
 187          //ÐÞ¸ÄÈÕÆÚ£º2020/05/16
 188          //ÐÞ¸ÄÄÚÈÝ£º³õ´ÎÍê³É»ù±¾¹¦ÄÜ
 189          //----------------------------
 190          void FramePacking(u8 FunctionCode,u8 *DataBuff)
 191          {
 192   1      
 193   1        u8 DataLen;//Êý¾ÝÇø³¤¶È,Ö¸ÓÐÐ§µÄÊý¾Ý³¤¶È£¬²»°üº¬Éè±¸±àÂëºÍ¹¦ÄÜÂë
 194   1        u8 *point = DataBuff;
 195   1        u8 Parity;
 196   1        u8 i=0; //Êý¾Ý´®ÏÂ±ê
 197   1        u8 SendStr[MaxSendStr] =    //ÏÂÃæÖ»»º´æµ½Ð£ÑéÎ»Ö®Ç°
 198   1                          {0xAA,0x55,//Êý¾Ý°üÍ·
 199   1                          0xFF,//Êý¾Ý¶Î³¤¶È¡¾MCUµÄÎÊÌâÂð£¿³õÊ¼»¯²»ÄÜÓÃ±äÁ¿¸³Öµ£¬ºóÃæÖØÐ´Ò»´Î°É¡¿
 200   1                          0x21,0x20,//·¢ËÍºÍ½ÓÊÕ·½Ê¶±ðÂë
 201   1                          0x00,//ÊÇ·ñÐèÒªÓ¦´ð
 202   1                          0xFF//¹¦ÄÜÂë£¬ÓÉ×ÜÐ­ÒéÎÄµµ¹æ¶¨¡¾MCUµÄÎÊÌâÂð£¿³õÊ¼»¯²»ÄÜÓÃ±äÁ¿¸³Öµ£¬ºóÃæÖØÐ´Ò»´Î°É¡¿
 203   1                          };
 204   1        if(FunctionCode == 0x70)  DataLen =2;
 205   1        else if(FunctionCode == 0x71) DataLen =23;  
 206   1        SendStr[2] = DataLen+4;//ÖØÐÂ°Ñ³¤¶ÈÐ´µ½Êý¾ÝÖ¡ÀïÃæ£¬+4
 207   1        SendStr[6] = FunctionCode;//ÖØÐÂ°Ñ¹¦ÄÜÂëÐ´µ½Êý¾ÝÖ¡ÀïÃæ                
 208   1        for(i=0;i<DataLen;i++)              
 209   1              SendStr[i+7] = *(point+i);  //Ìí¼ÓÊý¾ÝÇø  
 210   1                          
 211   1        Parity = SendStr[2];
 212   1        for(i=3;i<SendStr[2]+3;i++)//¼ÆËãÐ£ÑéÊý¾Ý
 213   1          Parity = Parity^SendStr[i];//°´Î»Òì»òÔËËã
 214   1                          
 215   1        SendStr[i]=Parity;i++;//Ìí¼ÓÐ£ÑéÊý¾Ý
 216   1        SendStr[i]=0x55;i++;
 217   1        SendStr[i]=0xAA;i++;//Ìí¼ÓÊý¾Ý°üÎ²²¿
 218   1      //Êý¾ÝÖ¡´ò°üÍê±Ï
 219   1      
 220   1        SendDataLen(SendStr,DataLen+10);//·¢ËÍÊý¾Ý°ü
 221   1      }
 222          
 223          
 224          /**************************************************************************
 225          ¹¦ÄÜ£ºSTC15µ¥Æ¬»úµÄ´®¿Ú·¢ËÍ×Ö½ÚµÄº¯Êý
 226          ²ÎÊý£ºdat:Òª·¢ËÍµÄÒ»¸ö×Ö½Ú   
 227          **************************************************************************/
 228          void UART_Send_Byte(unsigned char dat)
 229          {
 230   1          ES=0;    // Ê¹ÓÃ²éÑ¯·¢ËÍ½áÊø·½Ê½£¬½ûÖ¹ÖÐ¶Ï¸ÉÔ¤  ES ´®ÐÐÖÐ¶Ï ÔÊÐíÎ»
 231   1          SBUF = dat;
 232   1          while(!TI);     
 233   1          TI=0;  //´Ë¾ä¿ÉÒÔ²»Òª£¬²»Ó°ÏìºóÃæÊý¾ÝµÄ·¢ËÍ£¬Ö»¹©´úÂë²éÑ¯Êý¾ÝÊÇ·ñ·¢ËÍÍê³É
 234   1          ES=1;
 235   1      } 
 236          
C51 COMPILER V9.54   TASKUART                                                              05/20/2020 10:08:50 PAGE 5   

 237          
 238          
 239          
 240          void SendDataLen(u8 *DataBuff,u8 len)
 241          {
 242   1        u8 i=0;
 243   1        u8 *point = DataBuff;
 244   1        for(i=0;i<len;i++)
 245   1        {
 246   2          UART_Send_Byte(*(point+i));
 247   2        }
 248   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    915    ----
   CONSTANT SIZE    =     35    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     37      71
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
